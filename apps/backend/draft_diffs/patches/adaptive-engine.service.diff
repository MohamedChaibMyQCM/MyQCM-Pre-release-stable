--- a/src/adaptive-engine/adaptive-engine.service.ts
+++ b/src/adaptive-engine/adaptive-engine.service.ts
@@
-import { Injectable } from "@nestjs/common";
+import { Injectable, Logger } from "@nestjs/common";
@@
 export class AdaptiveEngineService {
   constructor(
@@
   ) {}
+
+  // Feature flag: enable corrected BKT math (posterior-then-learn, clamped params)
+  private readonly USE_CORRECTED_BKT = process.env.FF_BKT_CORRECTED === "true";
+  private readonly logger = new Logger(AdaptiveEngineService.name);
@@
-  async calculateBkt(
-    learner: AdaptiveLearner,
-    bktParams: BktParamsInterface,
-    accuracy_rate: number | null,
-  ): Promise<number> {
-    if (accuracy_rate === null || isNaN(accuracy_rate)) {
-      accuracy_rate = 0;
-    }
-
-    let { slipping_probability, guessing_probability, learning_rate } =
-      bktParams;
-    const { mastery } = learner;
-
-    if (!guessing_probability) {
-      guessing_probability = DefaultBktParamsConfig.guessing_probability;
-    }
-    if (!slipping_probability) {
-      slipping_probability = DefaultBktParamsConfig.slipping_probability;
-    }
-    if (!learning_rate) {
-      learning_rate = DefaultBktParamsConfig.learning_rate;
-    }
-    // Calculate the temporary mastery after the learning opportunity
-    const p_learn_temp = mastery + (1 - mastery) * learning_rate;
-
-    // Get accuracy threshold from Redis
-    const { correct_threshold } = (await this.redisService.get(
-      RedisKeys.getRedisAccuracyThresholdConfig(),
-      true,
-    )) as AccuracyThresholdConfigInterface;
-
-    // Calculate updated mastery based on accuracy
-    const isCorrect = accuracy_rate > correct_threshold;
-
-    const updatedMastery = ((): number => {
-      if (isCorrect) {
-        const numerator = p_learn_temp * (1 - slipping_probability);
-        const denominator =
-          numerator + (1 - p_learn_temp) * guessing_probability;
-        return numerator / denominator;
-      } else {
-        const numerator = p_learn_temp * slipping_probability;
-        const denominator =
-          numerator + (1 - p_learn_temp) * (1 - guessing_probability);
-        return numerator / denominator;
-      }
-    })();
-
-    return Math.min(1, Math.max(0, updatedMastery));
-  }
+  async calculateBkt(
+    learner: AdaptiveLearner,
+    bktParams: BktParamsInterface,
+    accuracy_rate: number | null,
+  ): Promise<number> {
+    // Fast path: preserve legacy behavior unless FF is enabled
+    if (!this.USE_CORRECTED_BKT) {
+      if (accuracy_rate === null || isNaN(accuracy_rate as any)) {
+        accuracy_rate = 0;
+      }
+
+      let { slipping_probability, guessing_probability, learning_rate } = bktParams;
+      const { mastery } = learner;
+
+      if (!guessing_probability) {
+        guessing_probability = DefaultBktParamsConfig.guessing_probability;
+      }
+      if (!slipping_probability) {
+        slipping_probability = DefaultBktParamsConfig.slipping_probability;
+      }
+      if (!learning_rate) {
+        learning_rate = DefaultBktParamsConfig.learning_rate;
+      }
+      const p_learn_temp = mastery + (1 - mastery) * learning_rate;
+      const { correct_threshold } = (await this.redisService.get(
+        RedisKeys.getRedisAccuracyThresholdConfig(),
+        true,
+      )) as AccuracyThresholdConfigInterface;
+      const isCorrect = accuracy_rate > correct_threshold;
+
+      const updatedMastery = ((): number => {
+        if (isCorrect) {
+          const numerator = p_learn_temp * (1 - slipping_probability);
+          const denominator = numerator + (1 - p_learn_temp) * guessing_probability;
+          return numerator / denominator;
+        } else {
+          const numerator = p_learn_temp * slipping_probability;
+          const denominator = numerator + (1 - p_learn_temp) * (1 - guessing_probability);
+          return numerator / denominator;
+        }
+      })();
+
+      return Math.min(1, Math.max(0, updatedMastery));
+    }
+
+    // Corrected path: posterior update first, then learning transition
+    const clamp01 = (x: number) => Math.max(0, Math.min(1, x));
+    const eps = 1e-12;
+
+    const { mastery } = learner;
+    let { slipping_probability, guessing_probability, learning_rate } = bktParams;
+
+    // Nullish checks: allow 0, only fallback if null/undefined
+    if (guessing_probability == null)
+      guessing_probability = DefaultBktParamsConfig.guessing_probability;
+    if (slipping_probability == null)
+      slipping_probability = DefaultBktParamsConfig.slipping_probability;
+    if (learning_rate == null) learning_rate = DefaultBktParamsConfig.learning_rate;
+
+    // Clamp
+    const s = clamp01(slipping_probability);
+    const g = clamp01(guessing_probability);
+    const t = clamp01(learning_rate);
+    const pL0 = clamp01(mastery);
+
+    // Map partial credit to boolean; if null, skip update (return unchanged)
+    const cfg = (await this.redisService.get(
+      RedisKeys.getRedisAccuracyThresholdConfig(),
+      true,
+    )) as AccuracyThresholdConfigInterface;
+    if (accuracy_rate == null || isNaN(accuracy_rate as any)) {
+      this.logger.debug("BKT skip: null/NaN accuracy_rate");
+      return pL0;
+    }
+    const correct = accuracy_rate >= cfg.correct_threshold;
+
+    // Likelihoods
+    const pC = pL0 * (1 - s) + (1 - pL0) * g;
+    const pI = pL0 * s + (1 - pL0) * (1 - g);
+    const post = correct
+      ? (pL0 * (1 - s)) / Math.max(1e-12, pC)
+      : (pL0 * s) / Math.max(1e-12, pI);
+    const next = clamp01(post + (1 - post) * t);
+    return next;
+  }
